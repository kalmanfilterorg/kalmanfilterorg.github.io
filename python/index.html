<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KalmanFilter: Kalman Filter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KalmanFilter
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Kalman Filter </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Here we have the <code>Python</code> implementation of discrete discrete Kalman filter (for nonlinear models is the extended Kalman filter). The repository is located at</p>
<p><a href="https://github.com/mannyray/KalmanFilter">https://github.com/mannyray/KalmanFilter</a></p>
<p>The examples here mirror the matlab <a href="https://kalmanfilter.org/matlab/md_discrete_discrete_documentation.html">examples</a>.</p>
<h2>Example 1</h2>
<p>The example is located in <code>python_implementation/discrete_discrete/examples/logistic.py</code>. You can <code>cd</code> into the directory and then run <code>python logistic.py</code>. We will describe the script here in detail:</p>
<div class="fragment"><div class="line">import sys</div><div class="line">sys.path.insert(0,&#39;..&#39;)</div><div class="line">from ddekf import *</div><div class="line">import numpy as np</div></div><!-- fragment --><p>Import the <code>ddekf</code> library from the parent directory as well as <code>numpy</code>. Implementation here uses <code>numpy</code>. Next, we set the seed for reproducability:</p>
<div class="fragment"><div class="line">np.random.seed(1)</div></div><!-- fragment --><p>Define the nonlinear discrete logistic growth model and its Jacobian function:</p>
<div class="fragment"><div class="line">rate = 0.01</div><div class="line">max_pop = 100.0</div><div class="line">def func(x,t):</div><div class="line">    return x + rate*x*(1 -(1/max_pop)*x)</div><div class="line"></div><div class="line">def jacobian_func(x,t):</div><div class="line">    return 1 + rate - (2*rate/max_pop)*x</div></div><!-- fragment --><p>For linear functions, the implemenation is equivalent to regular Kalman filter, for nonlinear functions this is the extended Kalman filter. Define the initial estimate <code>x_0</code>, estimate's covariance matrix <code>P_0</code>, process noise matrix <code>Q</code>, sensor noise matrix <code>R</code> and observation matrix <code>C</code>:</p>
<div class="fragment"><div class="line">x_0 = np.zeros((1,1))</div><div class="line">x_0[0][0] = max_pop/2</div><div class="line">P_0 = np.array([[1]])</div><div class="line">Q = np.array([[1]])</div><div class="line">R = np.array([[3]])</div><div class="line">C = np.array([[1]])</div></div><!-- fragment --><p>For accuracy, the implementation of the Kalman filter relies on square root of matrices. We compute the square root matrix:</p>
<div class="fragment"><div class="line">Q_root = np.linalg.cholesky(Q).transpose()</div><div class="line">R_root = np.linalg.cholesky(R).transpose()</div><div class="line">P_0_sqrt = np.linalg.cholesky(P_0).transpose()</div><div class="line">Q_root = np.array([[1]])</div></div><!-- fragment --><p>The square root matrix <code>A_sqrt</code> of a matrix <code>A</code> is such that <code>A = A_sqrt.dot(A_sqrt.transpose())</code>. Next, we define our time steps (using <code>start_time</code>, <code>finish_time</code> and <code>dt_between_measurements</code>), the total amount of <code>measurement_count</code> and <code>state_count</code>/<code>sensor_count</code> describes dimensions of the true system state and the measurements:</p>
<div class="fragment"><div class="line">start_time = 0</div><div class="line">finish_time = 10</div><div class="line">sensor_count = 1</div><div class="line">state_count = 1</div><div class="line">measurement_count = 1000</div><div class="line">dt_between_measurements = (finish_time - start_time)/measurement_count</div></div><!-- fragment --><p>Next, we run a simulation where we generate a run of the logistic model and store in <code>process_noise_data</code> (with noise). From <code>process_noise_data</code>, we can generate the noisy measurements and store them in <code>measurements</code>. The <code>process_noise_data</code> will be used later to judge our filter's performance.</p>
<div class="fragment"><div class="line">x = x_0</div><div class="line">x_noise = x_0</div><div class="line">ideal_data = []</div><div class="line">process_noise_data = []</div><div class="line">measurements = []</div><div class="line">times = []</div><div class="line">for ii in range(0,measurement_count):</div><div class="line">    current_time = ii*dt_between_measurements</div><div class="line">    times.append(current_time)</div><div class="line">    x = func(x,current_time)</div><div class="line">    ideal_data.append( x )</div><div class="line">    x_noise = func(x_noise,current_time) + Q_root.transpose().dot(np.random.randn(state_count,1))</div><div class="line">    process_noise_data.append(x_noise)</div><div class="line">    measurements.append(C.dot(x_noise) + R_root.transpose().dot(np.random.randn(sensor_count,1)))</div></div><!-- fragment --><p>Finally, we use <code>measurements</code> and our previously defined parameteres to run our Kalman filter:</p>
<div class="fragment"><div class="line">estimates, covariances = ddekf( func, jacobian_func, dt_between_measurements, start_time, state_count, sensor_count, measurement_count, C, Q_root, R_root, P_0_sqrt, x_0, measurements)</div></div><!-- fragment --><p>Now we plot the results:</p>
<div class="fragment"><div class="line">measurements_flat = [ x[0][0] for x in measurements ]</div><div class="line">estimates_flat = [ x[0][0] for x in estimates ]</div><div class="line">process_noise_data_flat = [ x[0][0] for x in process_noise_data ]</div><div class="line"></div><div class="line">line1, = plt.plot(times,measurements_flat,color=&#39;blue&#39;,label=&#39;Measurement&#39;)</div><div class="line">line2, = plt.plot(times,process_noise_data_flat,color=&#39;red&#39;,label=&#39;Real data&#39;)</div><div class="line">line3, = plt.plot(times,estimates_flat[1:],color=&#39;orange&#39;,label=&#39;Estimate&#39;)</div><div class="line">plt.legend(handles=[line1,line2,line3])</div><div class="line">plt.ylabel(&#39;Population&#39;)</div><div class="line">plt.xlabel(&#39;Time&#39;)</div><div class="line">plt.plot()</div><div class="line">plt.savefig(&#39;logistic2.png&#39;)</div><div class="line">plt.show()</div><div class="line">plt.close()</div><div class="line"></div><div class="line">line1, = plt.plot(times[0:99],measurements_flat[0:99],color=&#39;blue&#39;,label=&#39;Measurement&#39;)</div><div class="line">line2, = plt.plot(times[0:99],process_noise_data_flat[0:99],color=&#39;red&#39;,label=&#39;Real data&#39;)</div><div class="line">line3, = plt.plot(times[0:99],estimates_flat[1:100],color=&#39;orange&#39;,label=&#39;Estimate&#39;)</div><div class="line">plt.legend(handles=[line1,line2,line3])</div><div class="line">plt.ylabel(&#39;Population&#39;)</div><div class="line">plt.xlabel(&#39;Time&#39;)</div><div class="line">plt.plot()</div><div class="line">plt.savefig(&#39;logistic1.png&#39;)</div><div class="line">plt.show()</div><div class="line">plt.close()</div></div><!-- fragment --><div class="image">
<img src="logistic1.png" alt="drawing1" width="80%"/>
</div>
<div class="image">
<img src="logistic2.png" alt="drawing1" width="80%"/>
</div>
<h2>Example 2</h2>
<p>The example is located in <code>python_implementation/discrete_discrete/examples/linear.py</code> and has a model with two states. The result produced is in:</p>
<div class="fragment"><div class="line">[[5.05404334e-07 2.45085320e-08]</div><div class="line"> [2.45085320e-08 4.98056883e-07]]</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
